<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tracking down a register allocator bug - npmiller.fr</title>
  <link rel="icon" type="image/png" href="../res/favicon.png" />
  <link href='../css/ls.css' rel='stylesheet'>
</head>
<body>
<header class="top">
<a href="https://npmiller.fr">npmiller.fr</a>
</header>

<div class="article">
<h1 id="tracking-down-a-register-allocator-bug"><a
href="#tracking-down-a-register-allocator-bug">Tracking down a register
allocator bug</a></h1>
<p>This article describes the investigation of a bug found when running
<a href="https://www.gromacs.org/">GROMACS</a> testing using SYCL with
the <a href="https://github.com/intel/llvm/">DPC++ compiler</a> while
targeting AMD GPUs.</p>
<p>This was initially reported in the <code>intel/llvm</code> GitHub
repository issue-tracker <a
href="https://github.com/intel/llvm/issues/6209/">intel/llvm#6209</a>
and was using a <a
href="https://gitlab.com/gromacs/gromacs/-/tree/aa-hwe-release-2022-dpcpp-hip">specific
version</a> of GROMACS with SYCL support.</p>
<p>This bug will take us from the GROMACS source code all the way down
to the register allocation in the compiler backend.</p>
<h2 id="description-of-the-issue"><a
href="#description-of-the-issue">Description of the issue</a></h2>
<p>When running one of the GROMACS tests built with DPC++ targeting AMD,
the test crashes with the following output:</p>
<pre class="console"><code>Memory access fault by GPU node-4 (Agent handle: 0x215c1f0) on address 0x7ff5f0d6d000. Reason: Page not present or supervisor privilege.
Aborted (core dumped)</code></pre>
<p>This error indicates that the kernel is accessing invalid memory, for
example this can happen in simple out-of-bounds accesses.</p>
<p>It is reported that this issue appears on MI50 (<a
href="https://developer.amd.com/wp-content/resources/Vega_7nm_Shader_ISA.pdf">gfx906
ISA</a>), and MI200 (<a
href="https://developer.amd.com/wp-content/resources/CDNA2_Shader_ISA_4February2022.pdf">gfx90a
ISA</a>), but that it doesn’t fail on MI100 (<a
href="https://developer.amd.com/wp-content/resources/CDNA1_Shader_ISA_14December2020.pdf">gfx908
ISA</a>).</p>
<p>The specific test is being run as follows:</p>
<pre class="console"><code>SYCL_DEVICE_FILTER=hip:gpu ./bin/mdrun-pull-test</code></pre>
<h2 id="finding-the-kernel"><a href="#finding-the-kernel">Finding the
kernel</a></h2>
<p>The GROMACS application contains a lot of kernels so the first step
is to figure out exactly which kernel is causing the issue.</p>
<p>One easy way to do that is to use the ROCm debug environment variable
<code>AMD_LOG_LEVEL=4</code>. We can then find the last
<code>ShaderName</code> debug output before the crash:</p>
<pre class="console"><code>:3:rocvirtual.cpp           :2738: 6536108370963 us: 24086: [tid:0x7f5e78ab4740] ShaderName : _ZTS11NbnxmKernelILb1ELb1ELN5Nbnxm8ElecTypeE1ELNS0_7VdwTypeE1EE</code></pre>
<p>Which gives us the name of the last kernel to run on the GPU, which
is almost certainly the kernel that caused the access fault. This debug
output gives us the kernel name in its mangled form, but using the
<code>c++filt</code> tool we can easily turn it into a more readable
format, and so we get:</p>
<pre class="console"><code>c++filt _ZTS11NbnxmKernelILb1ELb1ELN5Nbnxm8ElecTypeE1ELNS0_7VdwTypeE1EE
typeinfo name for NbnxmKernel&lt;true, true, (Nbnxm::ElecType)1, (Nbnxm::VdwType)1&gt;</code></pre>
<p>Alternatively we can use the ROCm debugger <code>rocgdb</code>,
simply running the program under <code>rocgdb</code> after the segfault
the debugger will show which kernel it happened in and also allow us to
disassemble the kernel. Using the debugger can unfortunately only go so
far because debug information is not supported in DPC++ for AMD
targets.</p>
<p>With the debugger we get the following:</p>
<pre class="console"><code>Thread 3 &quot;mdrun-pull-test&quot; received signal SIGBUS, Bus error.
[Switching to thread 3, lane 0 (AMDGPU Lane 4:13:1:1/0 (0,0,0)[0,0,0])]
0x00007fffe5297078 in typeinfo name for NbnxmKernel&lt;true, true, (Nbnxm::ElecType)1, (Nbnxm::VdwType)1&gt; () from file:///path/to/gromacs/build/lib/libgromacs.so.7    #offset=75955456&amp;size=17664</code></pre>
<p>Using the <code>gdb</code> command <code>disas</code> we can then do
our first proper analysis step and look at the assembly dump showing on
which instruction the memory access fault is happening.</p>
<pre class="console"><code>Dump of assembler code for function _ZTS11NbnxmKernelILb1ELb1ELN5Nbnxm8ElecTypeE1ELNS0_7VdwTypeE1EE:
[...]
   0x00007fffe5297064 &lt;+1124&gt;:| global_load_dwordx2 v[14:15], v[5:6], off offset:16
   0x00007fffe529706c &lt;+1132&gt;:| s_waitcnt lgkmcnt(0)
   0x00007fffe5297070 &lt;+1136&gt;:| v_mov_b32_e32 v10, s41
   0x00007fffe5297074 &lt;+1140&gt;:| s_mov_b32 s64, s80
=&gt; 0x00007fffe5297078 &lt;+1144&gt;:| s_waitcnt vmcnt(0)
[...]</code></pre>
<p>The arrow indicates that the error is happening on the
<code>s_waitcnt vmcnt(0)</code>. This instruction waits for all the
memory operations using vector registers to be completed. Therefore the
likely culprit in this case is actually the
<code>global_load_dwordx2</code> instruction above.</p>
<p>At this point we know that the issue happens in the
<code>NbnxmKernel</code> and from the disassembly it seems likely to be
caused by a load instruction, this is consistent with the memory access
fault issue we’re seeing, the address used for this load instruction
must be incorrect in some way.</p>
<h2 id="comparing-the-assembly"><a
href="#comparing-the-assembly">Comparing the assembly</a></h2>
<p>We know that the application works on <code>gfx908</code> but not on
<code>gfx906</code> so a first step can be to compare the assembly
generated by both and see if any significant differences can be
identified.</p>
<p>To obtain the assembly we can use the environment variable
<code>SYCL_DUMP_IMAGES=1</code>, this is a DPC++ environment variable
which will dump all the available kernels images when running an
application. GROMACS is a fairly large application so we end up with 309
<code>.bin</code> images.</p>
<p>We can then use <code>grep</code> to search for the mangled kernel
name we got out of the debugger:</p>
<pre class="console"><code>% grep _ZTS11NbnxmKernelILb1ELb1ELN5Nbnxm8ElecTypeE1ELNS0_7VdwTypeE1EE *.bin
Binary file sycl_amdgcn142.bin matches</code></pre>
<p>The <code>.bin</code> files are HIP fat binaries, we can then extract
the actual device object file from them with:</p>
<pre class="console"><code>clang-offload-bundler --unbundle --type=o --targets=hipv4-amdgcn-amd-amdhsa--gfx906 --input=sycl_amdgcn142.bin --output=sycl_amdgcn142.bin.o</code></pre>
<p>And then disassemble the device objects with:</p>
<pre class="console"><code>llvm-objdump -d sycl_amdgcn142.bin.o &amp;&gt; sycl_amdgcn142.s</code></pre>
<p>Doing that for both architectures we end up with the assembly for
both and we can then use a diff tool to compare them.</p>
<p>Unfortunately at this point the differences between the two are very
significant and it’s very difficult to track down exactly where the
offending instruction is in the <code>gfx908</code> assembly, so more
work will be required to make use of this and we’ll come back to it
later.</p>
<h2 id="tracking-down-the-issue-in-the-source"><a
href="#tracking-down-the-issue-in-the-source">Tracking down the issue in
the source</a></h2>
<p>Knowing the kernel name we can find the source for it in GROMACS:</p>
<pre class="console"><code>src/gromacs/nbnxm/sycl/nbnxm_sycl_kernel_body.h</code></pre>
<ul>
<li><a
href="https://gitlab.com/gromacs/gromacs/-/blob/aa-hwe-release-2022-dpcpp-hip/src/gromacs/nbnxm/sycl/nbnxm_sycl_kernel_body.h#L663"
class="uri">https://gitlab.com/gromacs/gromacs/-/blob/aa-hwe-release-2022-dpcpp-hip/src/gromacs/nbnxm/sycl/nbnxm_sycl_kernel_body.h#L663</a></li>
</ul>
<p>Unfortunately for us this kernel is quite large and complicated,
roughly 400 lines of code with loops and many conditionals. And our
debugging options are very limited, indeed as mentioned above source
level debugging is not available, and neither is <code>printf</code>!
Both of these are available in the regular AMD toolchain but not yet
enabled in DPC++ for AMD at the time of this investigation.</p>
<p>So as a way to get source level information on where this bug is
happening we used the horrible snippet of code below:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="at">volatile</span> <span class="dt">int</span><span class="op">*</span> crash <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="op">*</span>crash<span class="op">++;</span></span></code></pre></div>
<p>You see adding this in the body of a kernel will cause it to crash
with a memory access fault error nearly identical to the one caused by
our bug, but since the error message prints the address of the memory
access fault it will always show <code>0</code> if this piece of code
caused it. And so this will show us if <code>*crash++</code> was run
before or after the offending line of code, which means that by moving
<code>*crash++</code> around in our kernel code and looking at the
resulting error we can eventually track down which line of code is
causing the issue.</p>
<p>After a lot of trial and error the <a
href="https://gitlab.com/gromacs/gromacs/-/blob/aa-hwe-release-2022-dpcpp-hip/src/gromacs/nbnxm/sycl/nbnxm_sycl_kernel_body.h#L793/">offending
line</a> in the kernel source was identified to be:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> imask <span class="op">=</span> a_plistCJ4<span class="op">[</span>j4<span class="op">].</span>imei<span class="op">[</span>imeiIdx<span class="op">].</span>imask<span class="op">;</span></span></code></pre></div>
<p>This matches what we were expecting since this line loads from both
<code>a_plistCJ4</code> and then from <code>imei</code>, so it must be
that either one of these loads triggers the error.</p>
<p>In addition, we also observed that the error never happens on the
first iteration of the loop this line is in, this information will
become important later on.</p>
<p>At this stage the obvious next step is to check whether
<code>j4</code> or <code>imeiIdx</code> are out of bounds for what
they’re indexing. A cursory look through the code didn’t spot anything
obvious that would suggest these indices may be wrong. But by that point
even though we still didn’t have access to a proper <code>printf</code>
we figured out that it was possible to use lower level
<code>printf</code> primitives provided by the HIP toolchain from within
the kernel, so we were able to try printing these indices:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> msg <span class="op">=</span> __ockl_fprintf_stdout_begin<span class="op">();</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>msg <span class="op">=</span> __ockl_fprintf_append_string_n<span class="op">(</span>msg<span class="op">,</span> <span class="st">&quot;debug: </span><span class="sc">%lu</span><span class="st">, </span><span class="sc">%lu\n</span><span class="st">&quot;</span><span class="op">,</span> <span class="dv">16</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>msg <span class="op">=</span> __ockl_fprintf_append_args<span class="op">(</span>msg<span class="op">,</span> <span class="dv">2</span><span class="op">,</span> j4<span class="op">,</span> imeiIdx<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span></code></pre></div>
<p>Now surprisingly after adding this bit of code before the offending
line the program started working correctly! This is usually indicative
that whatever we did to the code caused the compiler take a different
path and avoided triggering the issue.</p>
<p>Digging a little further around that idea, we found out that printing
just <code>imeiIdx</code> fixed the issue, and furthermore marking
<code>imeiIdx</code> as <code>volatile</code> also fixed the problem,
and finally since we also know that the first iteration is always
correct, we also ended up figuring out that disabling loop unrolling
with <code>-fno-unroll-loops</code> also fixes the issue.</p>
<p>So we now have a lot more information about what’s going on and
multiple ways of avoiding the issue, so we’re almost ready to dive back
in the assembly to see what we can figure out. But before we do, one of
the helpful thing we can do is to surround the offending line with
barriers:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>itemIdx<span class="op">.</span>barrier<span class="op">(</span>fence_space<span class="op">::</span>local_space<span class="op">);</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> imask <span class="op">=</span> a_plistCJ4<span class="op">[</span>j4<span class="op">].</span>imei<span class="op">[</span>imeiIdx<span class="op">].</span>imask<span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>itemIdx<span class="op">.</span>barrier<span class="op">(</span>fence_space<span class="op">::</span>local_space<span class="op">);</span></span></code></pre></div>
<p>Barriers are helpful because they’re lowered to recognizable
<code>s_barrier</code> instructions and they limit how the compiler can
re-organize the assembly around them which makes it a lot easier to
identify in the assembly where this line of source code is. And luckily
for us adding them doesn’t fix the issue we’re seeing, so we can use
them as a handy marker.</p>
<h2 id="diving-back-into-the-assembly"><a
href="#diving-back-into-the-assembly">Diving back into the
assembly</a></h2>
<p>Now we can look again at comparing assembly between all the different
cases we’ve identified, and see if we can spot what’s incorrect:</p>
<p>Assembly for <code>gfx906</code> with the extra barriers and no other
modification, the offending instruction is the
<code>global_load_dword</code> at the bottom. The generated assembly
looks different than what we originally got in <code>rocgdb</code> but
it still triggers the error:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>s_cbranch_scc1 <span class="dv">2000</span>                             <span class="co">; 0000000020AC: BF8507D0 &lt;_ZTS11NbnxmKernelILb1ELb1ELN5Nbnxm8ElecTypeE1ELNS0_7VdwTypeE1EE+0x23f0&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>s_ashr_i32 s43<span class="op">,</span> s42<span class="op">,</span> <span class="dv">31</span>                         <span class="co">; 0000000020B0: 902B9F2A</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>s_lshl_b64 s<span class="op">[</span><span class="dv">48</span><span class="op">:</span><span class="dv">49</span><span class="op">],</span> s<span class="op">[</span><span class="dv">42</span><span class="op">:</span><span class="dv">43</span><span class="op">],</span> <span class="dv">5</span>                <span class="co">; 0000000020B4: 8EB0852A</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>s_add_u32 s16<span class="op">,</span> s40<span class="op">,</span> s48                         <span class="co">; 0000000020B8: 80103028</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>v_lshlrev_b64 v<span class="op">[</span><span class="dv">7</span><span class="op">:</span><span class="dv">8</span><span class="op">],</span> <span class="dv">3</span><span class="op">,</span> v<span class="op">[</span><span class="dv">8</span><span class="op">:</span><span class="dv">9</span><span class="op">]</span>                 <span class="co">; 0000000020BC: D28F0007 00021083</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>s_addc_u32 s17<span class="op">,</span> s41<span class="op">,</span> s49                        <span class="co">; 0000000020C4: 82113129</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>s_waitcnt lgkmcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span>                            <span class="co">; 0000000020C8: BF8CC07F</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>v_mov_b32_e32 v6<span class="op">,</span> s17                           <span class="co">; 0000000020CC: 7E0C0211</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>v_add_co_u32_e64 v5<span class="op">,</span> s<span class="op">[</span><span class="dv">16</span><span class="op">:</span><span class="dv">17</span><span class="op">],</span> s16<span class="op">,</span> v7          <span class="co">; 0000000020D0: D1191005 00020E10</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>v_addc_co_u32_e64 v6<span class="op">,</span> s<span class="op">[</span><span class="dv">16</span><span class="op">:</span><span class="dv">17</span><span class="op">],</span> v6<span class="op">,</span> v8<span class="op">,</span> s<span class="op">[</span><span class="dv">16</span><span class="op">:</span><span class="dv">17</span><span class="op">]</span><span class="co">; 0000000020D8: D11C1006 00421106</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>s_waitcnt vmcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span> expcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span> lgkmcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span>         <span class="co">; 0000000020E0: BF8C0000</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>s_barrier                                       <span class="co">; 0000000020E4: BF8A0000</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>global_load_dword v52<span class="op">,</span> v<span class="op">[</span><span class="dv">5</span><span class="op">:</span><span class="dv">6</span><span class="op">],</span> off offset<span class="op">:</span><span class="dv">16</span>    <span class="co">; 0000000020E8: DC508010 347F0005</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>s_waitcnt vmcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span> expcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span> lgkmcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span>         <span class="co">; 0000000020F0: BF8C0000</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>s_barrier</span></code></pre></div>
<p>Assembly for <code>gfx906</code> with <code>imeiIdx</code> marked as
<code>volatile</code> (test passing):</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>s_cbranch_scc1 <span class="dv">2012</span>                              <span class="co">; 000000002114: BF8507DC &lt;_ZTS11NbnxmKernelILb1ELb1ELN5Nbnxm8ElecTypeE1ELNS0_7VdwTypeE1EE+0x2488&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>s_waitcnt vmcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span> expcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span> lgkmcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>s_barrier                                        <span class="co">; 00000000211C: BF8A0000</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>buffer_load_dword v8<span class="op">,</span> off<span class="op">,</span> s<span class="op">[</span><span class="dv">0</span><span class="op">:</span><span class="dv">3</span><span class="op">],</span> s33 offset<span class="op">:</span><span class="dv">16</span> <span class="co">; 000000002120: E0500010 21000800</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>s_nop <span class="dv">0</span>                                          <span class="co">; 000000002128: BF800000</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>buffer_load_dword v9<span class="op">,</span> off<span class="op">,</span> s<span class="op">[</span><span class="dv">0</span><span class="op">:</span><span class="dv">3</span><span class="op">],</span> s33 offset<span class="op">:</span><span class="dv">20</span> <span class="co">; 00000000212C: E0500014 21000900</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>s_ashr_i32 s47<span class="op">,</span> s46<span class="op">,</span> <span class="dv">31</span>                          <span class="co">; 000000002134: 902F9F2E</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>s_lshl_b64 s<span class="op">[</span><span class="dv">52</span><span class="op">:</span><span class="dv">53</span><span class="op">],</span> s<span class="op">[</span><span class="dv">46</span><span class="op">:</span><span class="dv">47</span><span class="op">],</span> <span class="dv">5</span>                 <span class="co">; 000000002138: 8EB4852E</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>s_add_u32 s20<span class="op">,</span> s44<span class="op">,</span> s52                          <span class="co">; 00000000213C: 8014342C</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>s_addc_u32 s21<span class="op">,</span> s45<span class="op">,</span> s53                         <span class="co">; 000000002140: 8215352D</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>s_add_u32 s24<span class="op">,</span> s20<span class="op">,</span> <span class="dv">16</span>                           <span class="co">; 000000002144: 80189014</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>s_addc_u32 s25<span class="op">,</span> s21<span class="op">,</span> <span class="dv">0</span>                           <span class="co">; 000000002148: 82198015</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>v_mov_b32_e32 v7<span class="op">,</span> s25                            <span class="co">; 00000000214C: 7E0E0219</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>s_mov_b32 s58<span class="op">,</span> s81                               <span class="co">; 000000002150: BEBA0051</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>s_waitcnt vmcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span>                               <span class="co">; 000000002154: BF8C0F70</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>flat_load_dword v11<span class="op">,</span> v<span class="op">[</span><span class="dv">8</span><span class="op">:</span><span class="dv">9</span><span class="op">]</span> glc                  <span class="co">; 000000002158: DC510000 0B000008</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>s_waitcnt vmcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span> lgkmcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span>                    <span class="co">; 000000002160: BF8C0070</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>v_lshlrev_b64 v<span class="op">[</span><span class="dv">5</span><span class="op">:</span><span class="dv">6</span><span class="op">],</span> <span class="dv">3</span><span class="op">,</span> v<span class="op">[</span><span class="dv">11</span><span class="op">:</span><span class="dv">12</span><span class="op">]</span>                <span class="co">; 000000002164: D28F0005 00021683</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>v_add_co_u32_e64 v5<span class="op">,</span> s<span class="op">[</span><span class="dv">20</span><span class="op">:</span><span class="dv">21</span><span class="op">],</span> s24<span class="op">,</span> v5           <span class="co">; 00000000216C: D1191405 00020A18</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>v_addc_co_u32_e64 v6<span class="op">,</span> s<span class="op">[</span><span class="dv">20</span><span class="op">:</span><span class="dv">21</span><span class="op">],</span> v7<span class="op">,</span> v6<span class="op">,</span> s<span class="op">[</span><span class="dv">20</span><span class="op">:</span><span class="dv">21</span><span class="op">]</span> <span class="co">; 000000002174: D11C1406 00520D07</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>global_load_dword v51<span class="op">,</span> v<span class="op">[</span><span class="dv">5</span><span class="op">:</span><span class="dv">6</span><span class="op">],</span> off               <span class="co">; 00000000217C: DC508000 337F0005</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>s_waitcnt vmcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span> expcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span> lgkmcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span>          <span class="co">; 000000002184: BF8C0000</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>s_barrier                                        <span class="co">; 000000002188: BF8A0000</span></span></code></pre></div>
<p>With <code>volatile</code> the code is changed a fair bit, in
particular a lot of the address calculation code is moved inside the two
barriers. But looking at the assembly closely we can see that it is
doing the same operations and the <code>global_load_dword</code> at the
bottom of that assembly snippet corresponds to the offending
<code>global_load_dword</code> in the previous snippet.</p>
<p>The interesting part about the assembly with <code>volatile</code> is
that it can help us figure out what corresponds to <code>imeiIdx</code>
in the assembly, here we can see the instruction:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>flat_load_dword v11<span class="op">,</span> v<span class="op">[</span><span class="dv">8</span><span class="op">:</span><span class="dv">9</span><span class="op">]</span> glc <span class="co">; 000000002158: DC510000 0B000008</span></span></code></pre></div>
<p>Just before the last stages of address computation before the
<code>global_load_dword</code> and that instruction is not in the
snippet without <code>volatile</code>. In addition looking at the ISA
document for <code>gfx906</code> you can see that <code>glc</code>
stands for <code>Globally Coherent</code> and marks that this
instruction bypasses the L1 cache. So it is quite likely that
<code>imeiIdx</code>, our <code>volatile</code> variable is being loaded
by this instruction, and so that in this assembly snippet it would
correspond to the vector register <code>v11</code>.</p>
<p>We can then see how <code>v11</code> is used:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>v_lshlrev_b64 v<span class="op">[</span><span class="dv">5</span><span class="op">:</span><span class="dv">6</span><span class="op">],</span> <span class="dv">3</span><span class="op">,</span> v<span class="op">[</span><span class="dv">11</span><span class="op">:</span><span class="dv">12</span><span class="op">]</span>                <span class="co">; 000000002164: D28F0005 00021683</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>v_add_co_u32_e64 v5<span class="op">,</span> s<span class="op">[</span><span class="dv">20</span><span class="op">:</span><span class="dv">21</span><span class="op">],</span> s24<span class="op">,</span> v5           <span class="co">; 00000000216C: D1191405 00020A18</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>v_addc_co_u32_e64 v6<span class="op">,</span> s<span class="op">[</span><span class="dv">20</span><span class="op">:</span><span class="dv">21</span><span class="op">],</span> v7<span class="op">,</span> v6<span class="op">,</span> s<span class="op">[</span><span class="dv">20</span><span class="op">:</span><span class="dv">21</span><span class="op">]</span> <span class="co">; 000000002174: D11C1406 00520D07</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>global_load_dword v51<span class="op">,</span> v<span class="op">[</span><span class="dv">5</span><span class="op">:</span><span class="dv">6</span><span class="op">],</span> off               <span class="co">; 00000000217C: DC508000 337F0005</span></span></code></pre></div>
<p>It is shifted by 3 into <code>v[5:6]</code>, as a register pair
<code>v[11:12]</code>, then <code>v5</code> and <code>v6</code> are used
in the addition instructions, which outputs are then used as the address
for <code>global_load_dword</code>.</p>
<p>We can then go back to the assembly of the case with errors and look
for this address computation pattern, to find which register corresponds
to <code>imeiIdx</code>, and we can easily find:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>[...]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>v_lshlrev_b64 v<span class="op">[</span><span class="dv">7</span><span class="op">:</span><span class="dv">8</span><span class="op">],</span> <span class="dv">3</span><span class="op">,</span> v<span class="op">[</span><span class="dv">8</span><span class="op">:</span><span class="dv">9</span><span class="op">]</span>                  <span class="co">; 0000000020BC: D28F0007 00021083</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>[...]</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>v_add_co_u32_e64 v5<span class="op">,</span> s<span class="op">[</span><span class="dv">16</span><span class="op">:</span><span class="dv">17</span><span class="op">],</span> s16<span class="op">,</span> v7           <span class="co">; 0000000020D0: D1191005 00020E10</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>v_addc_co_u32_e64 v6<span class="op">,</span> s<span class="op">[</span><span class="dv">16</span><span class="op">:</span><span class="dv">17</span><span class="op">],</span> v6<span class="op">,</span> v8<span class="op">,</span> s<span class="op">[</span><span class="dv">16</span><span class="op">:</span><span class="dv">17</span><span class="op">]</span> <span class="co">; 0000000020D8: D11C1006 00421106</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>s_waitcnt vmcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span> expcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span> lgkmcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span>          <span class="co">; 0000000020E0: BF8C0000</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>s_barrier                                        <span class="co">; 0000000020E4: BF8A0000</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>global_load_dword v52<span class="op">,</span> v<span class="op">[</span><span class="dv">5</span><span class="op">:</span><span class="dv">6</span><span class="op">],</span> off offset<span class="op">:</span><span class="dv">16</span>     <span class="co">; 0000000020E8: DC508010 347F0005</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>s_waitcnt vmcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span> expcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span> lgkmcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span>          <span class="co">; 0000000020F0: BF8C0000</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>s_barrier</span></code></pre></div>
<p>The shift by 3, followed by the two add instructions and then the
load, therefore in the broken assembly <code>imeiIdx</code> is stored in
<code>v8</code>.</p>
<p>So now that we know <code>v8</code> is supposed to be
<code>imeiIdx</code> we can scroll up in the assembly without
<code>volatile</code> and find out how it’s calculated, knowing that
<code>v0</code> and <code>v1</code> contain thread indices:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co">; v3 = v1</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>v_mov_b32_e32 v3<span class="op">,</span> v1                    <span class="co">; 000000001C90: 7E060301</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>[...]</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co">;  v15 = (v3 &lt;&lt; 3) + v0</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co">;  v15 = idy * 8 + idx  ; index flipped</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>v_lshl_add_u32 v15<span class="op">,</span> v3<span class="op">,</span> <span class="dv">3</span><span class="op">,</span> v0           <span class="co">; 000000001D30: D1FD000F 04010703</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>[...]</span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="co">; v8 = v15 &gt;&gt; 5</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="co">; v8 = v15 / 32</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>v_lshrrev_b32_e32 v8<span class="op">,</span> <span class="dv">5</span><span class="op">,</span> v15            <span class="co">; 000000001F3C: 20101E85</span></span></code></pre></div>
<p>And noting that in the source <code>imeiIdx</code> is calculated
by:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">unsigned</span> tidxi <span class="op">=</span> itemIdx<span class="op">.</span>get_local_id<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">unsigned</span> tidxj <span class="op">=</span> itemIdx<span class="op">.</span>get_local_id<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">unsigned</span> tidx  <span class="op">=</span> tidxj <span class="op">*</span> c_clSize <span class="op">+</span> tidxi<span class="op">;</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">unsigned</span> imeiIdx <span class="op">=</span> tidx <span class="op">/</span> prunedClusterPairSize<span class="op">;</span></span></code></pre></div>
<p>With <code>c_clSize = 8</code> and
<code>prunedClusterPairSize = 32</code>.</p>
<p>So we can see that the calculation of <code>imeiIdx</code> before the
loop is correct, this is consistent with what we were seeing that the
first iteration of the loop was always correct. But we can look further
into the loop after the load instruction to see what happens to
<code>v8</code>.</p>
<p>And very quickly we can see that after the incorrect instruction
<code>v8</code> is almost immediately re-used and its value erased, and
it doesn’t seem to be spilled to memory and re-loaded later or to have
its value re-calculated:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>v_ashrrev_i32_e32 v8<span class="op">,</span> <span class="dv">31</span><span class="op">,</span> v7 <span class="co">; 00000000210C: 22100E9F</span></span></code></pre></div>
<p>At this point the suspicion is clear, <code>v8</code> which is
supposed to contain <code>imeiIdx</code> is overridden when it shouldn’t
be. However it’s hard to say for sure as the loop is thousands of
instructions long. But we can try to confirm this by comparing further
with other cases that we know are working.</p>
<p>Now comparing the same assembly for <code>gfx908</code> that we also
know to be working, we observe the following:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode asm"><code class="sourceCode fasm"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>v_accvgpr_read_b32 v2<span class="op">,</span> a8                        <span class="co">; 000000002084: D3D84002 18000107</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>v_add_co_u32_e64 v5<span class="op">,</span> s<span class="op">[</span><span class="dv">16</span><span class="op">:</span><span class="dv">17</span><span class="op">],</span> s16<span class="op">,</span> v1           <span class="co">; 00000000208C: D1191005 00020210</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>v_addc_co_u32_e64 v6<span class="op">,</span> s<span class="op">[</span><span class="dv">16</span><span class="op">:</span><span class="dv">17</span><span class="op">],</span> v6<span class="op">,</span> v2<span class="op">,</span> s<span class="op">[</span><span class="dv">16</span><span class="op">:</span><span class="dv">17</span><span class="op">]</span> <span class="co">; 000000002094: D11C1006 00420506</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>s_waitcnt vmcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span> expcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span> lgkmcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span>          <span class="co">; 00000000209C: BF8C0000</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>s_barrier                                        <span class="co">; 0000000020A0: BF8A0000</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>global_load_dword v52<span class="op">,</span> v<span class="op">[</span><span class="dv">5</span><span class="op">:</span><span class="dv">6</span><span class="op">],</span> off offset<span class="op">:</span><span class="dv">16</span>     <span class="co">; 0000000020A4: DC508010 347F0005</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>s_waitcnt vmcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span> expcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span> lgkmcnt<span class="op">(</span><span class="dv">0</span><span class="op">)</span>          <span class="co">; 0000000020AC: BF8C0000</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>s_barrier </span></code></pre></div>
<p>In the <code>gfx908</code> snippet we see that the shift by 3 that we
were observing previously is not near the load but instead there is a
<code>v_accvgpr_read_b32</code> instruction. Looking further up in the
assembly we can see that <code>imeiIdx</code> is calculated outside of
the loop as previously, but then its value is stored in a register
<code>a8</code>, and then loaded before the
<code>global_load_dword</code>. And <code>a8</code> is not written to
anywhere else in the program so the value of <code>imeiIdx</code> will
be correct for the entire loop.</p>
<p>Looking at the ISA documents we can see that <code>a8</code> is an
ACC vector register, these registers are part of the matrix
multiplication unit, but it seems here that it is used for spilling the
value of <code>imeiIdx</code>, it is important to note that
<code>gfx906</code> doesn’t have this matrix multiplication unit or ACC
register and that <code>gfx90a</code> MI200, which we know also fails,
does have these registers, but looking through the LLVM code base we
could figure out that on <code>gfx90a</code> these can be used as
general purpose vector registers and so they are not used for spilling
like they are on <code>gfx908</code>.</p>
<p>Furthermore we can also look at the assembly for <code>gfx906</code>
but when loop unrolling is disabled. In that scenario it looks just like
the regular <code>gfx906</code> however, the register matching
<code>imeiIdx</code> is not re-used in the body of the loop.</p>
<p>So we have a fairly strong idea of why it is failing, that is to say
<code>v8</code> is being incorrectly re-used, but we don’t now why or
how to fix it yet.</p>
<h2 id="diving-further-into-the-compiler"><a
href="#diving-further-into-the-compiler">Diving further into the
compiler</a></h2>
<p>Now we need to analyze what the compiler is doing and try to
understand why <code>v8</code> is re-used, but to do that we first need
to narrow down a bit the compilation of the kernels so we can look at
what the compiler is doing without too much noise from unrelated
kernels.</p>
<p>So first we build with verbose output to try and identify the
compilation commands for the <code>Nbnxm</code> kernel:</p>
<pre class="console"><code>make VERBOSE=1 mdrun-pull-test -j$(nproc)</code></pre>
<p>From that we see that the <code>Nbnxm</code> kernel is actually built
in four different configurations:</p>
<pre class="console"><code>[ 28%] Building CXX object src/gromacs/CMakeFiles/libgromacs.dir/nbnxm/sycl/nbnxm_sycl_kernel_body_f_prune.cpp.o
[ 28%] Building CXX object src/gromacs/CMakeFiles/libgromacs.dir/nbnxm/sycl/nbnxm_sycl_kernel_body_f_noprune.cpp.o
[ 28%] Building CXX object src/gromacs/CMakeFiles/libgromacs.dir/nbnxm/sycl/nbnxm_sycl_kernel_body_fv_noprune.cpp.o
[ 28%] Building CXX object src/gromacs/CMakeFiles/libgromacs.dir/nbnxm/sycl/nbnxm_sycl_kernel_body_fv_prune.cpp.o</code></pre>
<p>Going into that build directory we can use <code>grep</code> again to
figure out which of these contain our offending kernel:</p>
<pre class="console"><code>% grep _ZTS11NbnxmKernelILb1ELb1ELN5Nbnxm8ElecTypeE1ELNS0_7VdwTypeE1EE *
Binary file nbnxm_sycl_kernel_body_fv_prune.cpp.o matches</code></pre>
<p>Which means it’s the <code>fv_prune</code> configuration that is
causing issues. This <code>.o</code> file here doesn’t actually contain
assembly, but LLVM IR bitcode, with DPC++ for AMD the actual assembly is
generated during the linking stage by <code>lld</code>.</p>
<p>We can extract the bitcode with the
<code>clang-offload-bundler</code>:</p>
<pre class="console"><code>clang-offload-bundler --unbundle --type=o --targets=sycl-amdgcn-amd-amdhsa-gfx906 --input=nbnxm_sycl_kernel_body_fv_prune.cpp.o --output=fv_prune.bc</code></pre>
<p>Now in theory we could then simply build this bitcode file with
<code>llc</code> and get similar assembly and use that to investigate
the compiler, however trying that produces assembly that is fairly
different, so to manually reproduce what the compiler is doing in the
regular build we need to look further.</p>
<p>As stated previously on AMD the assembly is generated during the link
step by <code>lld</code>, looking at the output of the verbose make
command, we can identify the linking stage:</p>
<pre class="console"><code>/path/to/llvm/build/bin/clang++ -fPIC -O3 -DNDEBUG -shared -Wl,-soname,libgromacs.so.7 -o ../../lib/libgromacs.so.7.0.0 @CMakeFiles/libgromacs.dir/objects1.rsp -Wl,-rpath,/path/to/gromacs/build2/lib: -ffast-math -fsycl -fsycl-device-code-split=per_kernel -fsycl-targets=amdgcn-amd-amdhsa -Xsycl-target-backend --offload -arch=gfx906 -lrt ../external/build-fftw/fftwBuild-prefix/lib/libfftw3f.a -lpthread -ffast-math -fsycl -fsycl-device-code-split=per_kernel -fsycl-targets=amdgcn-amd-amdhsa -Xsycl-target-backend --offload-arch=gfx906 -lm ../../lib/libmuparser.so.2.3.2 -lm</code></pre>
<p>The input files, including the
<code>nbnxm_sycl_kernel_body_fv_prune.cpp.o</code> file we’re interested
in are listed in the <code>objects1.rsp</code> file. We can then run
this command with <code>-###</code>, this will make the clang driver
list all the underlying commands that would be executed during this
specific operation.</p>
<p>The output of this is quite large as GROMACS is a large application
so we’ll just show the interesting lines, but looking at it you can find
a command similar to the one we’ve used above to extract the
bitcode:</p>
<pre class="console"><code>&quot;/path/to/llvm/build/bin/clang-offload-bundler&quot; &quot;-type=o&quot; &quot;-targets=host-x86_64-unknown-linux-gnu,sycl-amdgcn-amd-amdhsa-gfx906&quot; &quot;-input=CMakeFiles/libgromacs.dir/nbnxm/sycl/nbnxm_sycl_kernel_body_fv_prune.cpp.o&quot; &quot;-output=/tmp/nbnxm_sycl_kernel_body_fv_prune-b557cf.o&quot; &quot;-output=/tmp/nbnxm_sycl_kernel_body_fv_prune-ec4a19/nbnxm_sycl_kernel_body_fv_prune-gfx906.o&quot; &quot;-unbundle&quot; &quot;-allow-missing-bundles&quot;</code></pre>
<p>Then you can track the bitcode file being used in a very long
<code>llvm-link</code> command:</p>
<pre class="console"><code>&quot;/path/to/llvm/build/bin/llvm-link&quot; [...] &quot;/tmp/nbnxm_sycl_kernel_body_fv_prune-ec4a19/nbnxm_sycl_kernel_body_fv_prune-gfx906.o&quot; [...] &quot;-o&quot; &quot;/tmp/alignedallocator-a0f82a/alignedallocator-gfx906.bc&quot; &quot;--suppress-warnings&quot;</code></pre>
<p>This command links all the bitcode files from all the kernels in
GROMACS together into one very large bitcode file
<code>alignedallocator-gfx906.bc</code>, this is because with
<code>SYCL_EXPORT</code> some symbols may be defined in different
translation units.</p>
<p>Then <code>sycl-post-link</code> is used and splits this large
bitcode file per kernel instead of originally per translation unit:</p>
<pre class="console"><code>&quot;/path/to/llvm/build/bin/sycl-post-link&quot; &quot;-split=kernel&quot; &quot;-symbols&quot; &quot;-emit-exported-symbols&quot; &quot;-lower-esimd&quot; &quot;-O3&quot; &quot;-spec-const=default&quot; &quot;-o&quot; &quot;/tmp/alignedallocator-c32144/alignedallocator-gfx906.bc&quot; &quot;/tmp/alignedallocator-a0f82a/alignedallocator-gfx906.bc&quot;</code></pre>
<p>Since this is splitting one large bitcode files into a number of
other bitcode files the following commands working on the bitcode files
will be wrapped in <code>llvm-foreach</code>. And this is where we reach
the command we’re actually interested in:</p>
<pre class="console"><code>&quot;/path/to/llvm/build/bin/llvm-foreach&quot; &quot;--out-ext=out&quot; &quot;--in-file-list=/tmp/alignedallocator-7746ed/alignedallocator-gfx906.o&quot; &quot;--in-replace=/tmp/alignedallocator-7746ed/alignedallocator-gfx906.o&quot; &quot;--out-file-list=/tmp/alignedallocator-d6ebb0/alignedallocator-gfx906.out&quot; &quot;--out-replace=/tmp/alignedallocator-d6ebb0/alignedallocator-gfx906.out&quot; &quot;--&quot; &quot;/path/to/llvm/build/bin/lld&quot; &quot;-flavor&quot; &quot;gnu&quot; &quot;--no-undefined&quot; &quot;-shared&quot; &quot;-plugin-opt=-amdgpu-internalize-symbols&quot; &quot;-plugin-opt=mcpu=gfx906&quot; &quot;-plugin-opt=O3&quot; &quot;-o&quot; &quot;/tmp/alignedallocator-d6ebb0/alignedallocator-gfx906.out&quot; &quot;/tmp/alignedallocator-7746ed/alignedallocator-gfx906.o&quot;</code></pre>
<p>This calls <code>lld</code> over all of the bitcode files, and this
is the step that actually ends up generating the assembly and object
file. So we can try to extract just the <code>lld</code> command and use
that on our bitcode file we extracted manually earlier:</p>
<pre class="console"><code>&quot;/path/to/llvm/build/bin/lld&quot; &quot;-flavor&quot; &quot;gnu&quot; &quot;--no-undefined&quot; &quot;-shared&quot; &quot;-plugin-opt=-amdgpu-internalize-symbols&quot; &quot;-plugin-opt=mcpu=gfx906&quot; &quot;-plugin-opt=O3&quot; &quot;-o&quot; &quot;fv_prune.out&quot; &quot;fv_prune.bc&quot;</code></pre>
<p>And then we can disassemble <code>fv_prune.out</code> with
<code>llvm-objdump</code> and as opposed to <code>llc</code> this file
is actually very similar to our problematic assembly and shows the
pattern we are looking for of <code>v8</code> being overridden.</p>
<p>Now that we have narrowed down building the <code>Nbnxm</code> kernel
to a fairly simple command we can move on to using one of the most
powerful LLVM debugging tool: <code>-print-after-all</code>, with this
flag the LLVM compiler will print the IR and Machine IR after every
single pass or stage of the compiler. This is extremely helpful to debug
however it does produce huge amounts of output which is why we couldn’t
use it on the commands building the entirety of GROMACS and had to
narrow it down first.</p>
<pre class="console"><code>&quot;/path/to/llvm/build/bin/lld&quot; &quot;-flavor&quot; &quot;gnu&quot; &quot;--no-undefined&quot; &quot;-shared&quot; &quot;-plugin-opt=-amdgpu-internalize-symbols&quot; &quot;-plugin-opt=mcpu=gfx906&quot; &quot;-plugin-opt=O3&quot; &quot;-o&quot; &quot;fv_prune.out&quot; &quot;fv_prune.bc&quot; -mllvm -print-after-all -mllvm -filter-print-funcs=_ZTS11NbnxmKernelILb1ELb1ELN5Nbnxm8ElecTypeE1ELNS0_7VdwTypeE1EE &amp;&gt; print-after-all.txt</code></pre>
<p>And <code>-filter-print-funcs</code> narrows down the output further
to only the function we’re interested in.</p>
<p>Now we can look through the output of this command and look for our
problematic instructions, so again the pattern of a load between two
barriers, and starting from the bottom of the file we end up finding the
following Machine IR:</p>
<pre class="console"><code>renamable $sgpr57 = S_ASHR_I32 renamable $sgpr56, 31, implicit-def dead $scc
renamable $sgpr58_sgpr59 = S_LSHL_B64 renamable $sgpr56_sgpr57, 5, implicit-def dead $scc
renamable $sgpr16 = S_ADD_U32 renamable $sgpr42, renamable $sgpr58, implicit-def $scc
renamable $vgpr7_vgpr8 = V_LSHLREV_B64_e64 3, $vgpr8_vgpr9, implicit $exec
renamable $sgpr17 = S_ADDC_U32 renamable $sgpr43, renamable $sgpr59, implicit-def dead $scc, implicit killed $scc
S_WAITCNT 49279
$vgpr6 = V_MOV_B32_e32 killed $sgpr17, implicit $exec, implicit $exec
renamable $vgpr5, renamable $sgpr16_sgpr17 = V_ADD_CO_U32_e64 killed $sgpr16, killed $vgpr7, 0, implicit $exec
renamable $vgpr6, dead renamable $sgpr16_sgpr17 = V_ADDC_U32_e64 killed $vgpr6, killed $vgpr8, killed $sgpr16_sgpr17, 0, implicit $exec
S_WAITCNT 0
S_BARRIER
renamable $vgpr50 = GLOBAL_LOAD_DWORD renamable $vgpr5_vgpr6, 16, 0, implicit $exec :: (load (s32) from %ir.1262, !tbaa !84, addrspace 1)
S_WAITCNT 0
S_BARRIER</code></pre>
<p>This is clearly our problematic code, we can see the two barriers,
the load, the shift by 3 and the additions, and we can see
<code>vgpr8</code> being used, the important instructions are the
following:</p>
<pre class="console"><code>[...]
renamable $vgpr7_vgpr8 = V_LSHLREV_B64_e64 3, $vgpr8_vgpr9, implicit $exec
[...]
renamable $vgpr6, dead renamable $sgpr16_sgpr17 = V_ADDC_U32_e64 killed $vgpr6, killed $vgpr8, killed $sgpr16_sgpr17, 0, implicit $exec</code></pre>
<p>What is very interesting here is that in the <code>V_ADDC</code>
instruction the <code>$vgpr8</code> operand is marked
<code>killed</code> which tells the compiler that the register is not
used after this instruction and can be re-used. This is why
<code>v8</code> is being re-used in the body of the loop. In addition
even the shift by 3 is overriding <code>v8</code> so it definitely won’t
be correct in the next iteration.</p>
<p>So we scroll back up our <code>print-after-all.txt</code> file up
until we find the first pass that introduced these seemingly incorrect
instructions, and we track it down to:</p>
<pre class="console"><code># *** IR Dump After Virtual Register Rewriter (virtregrewriter) ***:</code></pre>
<p>This is the first pass that introduces this killed
<code>$vgpr8</code>, but this pass is also the first pass where the
Machine IR has machine registers, it runs right after the register
allocator to do the actual replacement between the virtual registers and
the newly allocated physical registers.</p>
<p>Scrolling up further to look at the code after the greedy register
allocator, we can see that the code at that point looks like:</p>
<pre class="console"><code># *** IR Dump After Greedy Register Allocator (greedy) ***:
[...]
19776B|   S_WAITCNT 0
19792B|   S_BARRIER
19824B|   renamable $sgpr57 = S_ASHR_I32 renamable $sgpr56, 31, implicit-def dead $scc
19872B|   renamable $sgpr58_sgpr59 = S_LSHL_B64 renamable $sgpr56_sgpr57, 5, implicit-def dead $scc
19888B|   renamable $sgpr16 = S_ADD_U32 renamable $sgpr42, renamable $sgpr58, implicit-def $scc
19904B|   renamable $sgpr17 = S_ADDC_U32 renamable $sgpr43, renamable $sgpr59, implicit-def dead $scc, implicit $scc
19936B|   %3340:vgpr_32 = COPY killed renamable $sgpr17
19944B|   %3963:vreg_64 = V_LSHLREV_B64_e64 3, %3078:vreg_64, implicit $exec
19952B|   %3962:vreg_64 = COPY %3963:vreg_64
19960B|   undef %893.sub0:vreg_64, renamable $sgpr16_sgpr17 = V_ADD_CO_U32_e64 killed $sgpr16, %3962.sub0:vreg_64, 0, implicit $exec
19976B|   %893.sub1:vreg_64, dead renamable $sgpr16_sgpr17 = V_ADDC_U32_e64 %3340:vgpr_32, %3962.sub1:vreg_64, killed $sgpr16_sgpr17, 0, implicit $exec
20064B|   %3772:vgpr_32 = GLOBAL_LOAD_DWORD %893:vreg_64, 16, 0, implicit $exec :: (load (s32) from %ir.1262, !tbaa !84, addrspace 1)
20080B|   S_WAITCNT 0
20096B|   S_BARRIER</code></pre>
<p>We can see the shift by 3, with virtual register <code>%3078</code>,
that goes into <code>%3963</code>, which is then copied to
<code>%3962</code>, and then used as operand for the addition, but as
you can see at this point it is not yet marked killed.</p>
<p>And looking at the pass before the register allocation we see the
following code:</p>
<pre class="console"><code>4376B|    %889:vreg_64 = V_LSHLREV_B64_e64 3, %3078:vreg_64, implicit $exec
[...]
19776B|   S_WAITCNT 0
19792B|   S_BARRIER
19824B|   %887.sub1:sreg_64 = S_ASHR_I32 %887.sub0:sreg_64, 31, implicit-def dead $scc
19872B|   %891:sreg_64 = S_LSHL_B64 %887:sreg_64, 5, implicit-def dead $scc
19888B|   %3326:sreg_32 = S_ADD_U32 %692.sub2:sgpr_128, %891.sub0:sreg_64, implicit-def $scc
19904B|   %3327:sreg_32 = S_ADDC_U32 %692.sub3:sgpr_128, %891.sub1:sreg_64, implicit-def dead $scc, implicit $scc
19936B|   %3340:vgpr_32 = COPY %3327:sreg_32
19944B|   undef %893.sub0:vreg_64, %3334:sreg_64_xexec = V_ADD_CO_U32_e64 %3326:sreg_32, %889.sub0:vreg_64, 0, implicit $exec
19952B|   %893.sub1:vreg_64, dead %3335:sreg_64_xexec = V_ADDC_U32_e64 %3340:vgpr_32, %889.sub1:vreg_64, %3334:sreg_64_xexec, 0, implicit $exec
20064B|   %3772:vgpr_32 = GLOBAL_LOAD_DWORD %893:vreg_64, 16, 0, implicit $exec :: (load (s32) from %ir.1262, !tbaa !84, addrspace 1)
20080B|   S_WAITCNT 0
20096B|   S_BARRIER</code></pre>
<p>Looking at this code it’s important to note that the shift by 3 is
actually not inside of the loop, it’s before the loop starts and its
value is simply used inside of the loop for the additions. This code
should work absolutely fine, but it seems that the greedy register
allocator moves this shift inside of the loop, and then the virtual
register rewriter marks the <code>v8</code> operand as killed.</p>
<p>Now at this point in our investigation, we need to start debugging
the actual code of these passes to understand why they are doing these
transformations and try to figure out what is going wrong. One good way
to start with that is to use <code>-debug-only=regalloc</code>, this
will print debugging output for the register allocation. However it
doesn’t support the <code>-filter-print-funcs=</code> flag like
<code>-print-after-all</code> which leads to huge output so we need to
reduce our bitcode file a little further.</p>
<p>To do that we can use <code>opt</code> to remove from the bitcode all
the kernels we’re not interested in:</p>
<pre class="console"><code>/path/to/llvm/build/bin/opt --internalize-public-api-list=_ZTS11NbnxmKernelILb1ELb1ELN5Nbnxm8ElecTypeE1ELNS0_7VdwTypeE1EE --internalize --globaldce fv_prune.bc -o fv_prune_trimmed.bc</code></pre>
<p>This command will mark <code>internal</code> all the functions that
are not listed in the <code>--internalize-public-api-list</code> flag,
and then run a <code>globaldce</code> pass which will eliminate all the
internal symbols. This trims down our bitcode file quite
significantly.</p>
<p>Then we can also run the compilation up until right before the greedy
register allocator, this way we can just run the passes we’re trying to
debug:</p>
<pre class="console"><code>&quot;/path/to/llvm/build/bin/lld&quot; &quot;-flavor&quot; &quot;gnu&quot; &quot;--no-undefined&quot; &quot;-shared&quot; &quot;-plugin-opt=-amdgpu-internalize-symbols&quot; &quot;-plugin-opt=mcpu=gfx906&quot; &quot;-plugin-opt=O3&quot; &quot;-o&quot; &quot;pre_greedy.mir&quot; &quot;fv_prune_trimmed.bc&quot; -mllvm -stop-before=greedy</code></pre>
<p><code>lld</code> is not really setup to use this
<code>stop-before</code> parameter and so it will crash but not before
giving us the output we want in <code>pre_greedy.mir</code>, this will
now contain the Machine IR before the greedy register allocator, the one
with the shift by 3 outside of the loop.</p>
<p>We can then use <code>llc</code> to run only the specific pass and
get debug output from register allocation:</p>
<pre class="console"><code>/path/to/llvm/build/bin/llc -start-before=greedy -stop-after=virtregrewriter -mcpu=gfx906 -debug-only=regalloc pre_greedy.mir -o post_regalloc.mir &amp;&gt; regalloc.txt</code></pre>
<p>This command will run just the passes between <code>greedy</code> and
<code>virtregrewriter</code>, and print debug output for the register
allocation <code>-debug-only=regalloc</code>. The names for the passes
can be seen in the <code>-print-after-all</code> dumps in parenthesis
next to the longer name of the passes. Note that this
<code>regalloc</code> name can be found in the source of the passes
mentioned above, for example in:</p>
<pre class="console"><code>/path/to/llvm/llvm/lib/CodeGen/RegAllocGreedy.cpp</code></pre>
<p>Under:</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#define DEBUG_TYPE </span><span class="st">&quot;regalloc&quot;</span></span></code></pre></div>
<p>This in turns control the <code>LLVM_DEBUG</code> directives in that
file and places them under the <code>regalloc</code> keyword.</p>
<p>So now that we have the debug output from the register allocation we
can look through that, and to find what we’re looking for we can simply
look for the virtual registers that we spotted above so
<code>%3078</code>, and we find the following debug output:</p>
<pre class="console"><code>Removing 1 back-copies.
Removing 16328r|%3961:vreg_64 = COPY %890:vreg_64
  blit [3440r,3488B:0): [3440r;3488B)=0(%3961)(recalc)
  blit [16192B,38336B:0): [16192B;16312r)=0(%3961)(recalc) [16312r;16336r)=1(%3962)(recalc) [16336r;38336B)=0(%3961)(recalc)
  rewr %bb.6|   3440r:0|%3961:vreg_64 = V_LSHLREV_B64_e64 3, %3078:vreg_64, implicit $exec
  rewr %bb.90|  16320B:1|   undef %894.sub0:vreg_64, %3334:sreg_64_xexec = V_ADD_CO_U32_e64 %3326:sreg_32, %3962.sub0:vreg_64, 0, implicit $exec
  rewr %bb.90|  16336B:1|   %894.sub1:vreg_64, dead %3335:sreg_64_xexec = V_ADDC_U32_e64 %3340:vgpr_32, %3962.sub1:vreg_64, %3334:sreg_64_xexec, 0, implicit $exec
  rewr %bb.90|  16312B:0|   %3962:vreg_64 = COPY %3961:vreg_64
queuing new interval: %3961 [3440r,3488B:0)[16192B,38336B:0) 0@3440r  L000000000000000C [3440r,3488B:1)[16192B,38336B:1) 0@x 1@3440r  L0000000000000003 [3440r,3488B:1)[1    6192B,38336B:1) 0@x 1@3440r  weight:3.681593e-04
Enqueuing %3961
queuing new interval: %3962 [16312r,16336r:0) 0@16312r  L000000000000000C [16312r,16336r:0) 0@16312r  L0000000000000003 [16312r,16320r:0) 0@16312r  weight:5.705815e-02
Enqueuing %3962

selectOrSplit VReg_64:%3961 [3440r,3488B:0)[16192B,38336B:0) 0@3440r  L000000000000000C [3440r,3488B:1)[16192B,38336B:1) 0@x 1@3440r  L0000000000000003 [3440r,3488B:1)[1    6192B,38336B:1) 0@x 1@3440r  weight:3.681593e-04 w=3.681593e-04
RS_Spill Cascade 0
should evict: %677 [96r,13936r:0)[16144B,38336B:0) 0@96r  weight:6.930721e-05 w= 6.930721e-05
should evict: %677 [96r,13936r:0)[16144B,38336B:0) 0@96r  weight:6.930721e-05 w= 6.930721e-05
Inline spilling VReg_64:%3961 [3440r,3488B:0)[16192B,38336B:0) 0@3440r  L000000000000000C [3440r,3488B:1)[16192B,38336B:1) 0@x 1@3440r  L0000000000000003 [3440r,3488B:1)    [16192B,38336B:1) 0@x 1@3440r  weight:3.681593e-04
From original %890
|   remat:  16308r| %3963:vreg_64 = V_LSHLREV_B64_e64 3, %3078:vreg_64, implicit $exec
|           16312e| %3962:vreg_64 = COPY killed %3963:vreg_64

All defs dead: dead %3961:vreg_64 = V_LSHLREV_B64_e64 3, %3078:vreg_64, implicit $exec
Remat created 1 dead defs.
Deleting dead def 3440r|dead %3961:vreg_64 = V_LSHLREV_B64_e64 3, %3078:vreg_64, implicit $exec
unassigning %3078 from $vgpr8_vgpr9: VGPR8_LO16 VGPR8_HI16 VGPR9_LO16 VGPR9_HI16
Enqueuing %3078
Shrink: %3078 [2224r,2240r:0)[2240r,3488B:1)[16192B,38336B:1) 0@2224r 1@2240r  L0000000000000003 [2224r,3440r:0) 0@2224r  L000000000000000C [2240r,3488B:0)[16192B,38336B    :0) 0@2240r  weight:1.520717e-01</code></pre>
<p>Now this is quite a lot so first let’s roll back to the beginning of
the debug output where the full kernel is shown, we can see that at that
point, the code looks like this:</p>
<pre class="console"><code>3440B|    %890:vreg_64 = V_LSHLREV_B64_e64 3, %3078:vreg_64, implicit $exec
[...]
16320B|   undef %894.sub0:vreg_64, %3334:sreg_64_xexec = V_ADD_CO_U32_e64 %3326:sreg_32, %890.sub0:vreg_64, 0, implicit $exec
16336B|   %894.sub1:vreg_64, dead %3335:sreg_64_xexec = V_ADDC_U32_e64 %3340:vgpr_32, %890.sub1:vreg_64, %3334:sreg_64_xexec, 0, implicit $exec
16352B|   %3772:vgpr_32 = GLOBAL_LOAD_DWORD %894:vreg_64, 16, 0, implicit $exec :: (load (s32) from %ir.imask97.i, !tbaa !75, addrspace 1)
16368B|   S_WAITCNT 0
16384B|   S_BARRIER</code></pre>
<p>In this snippet we can see that the shift by 3 is at
<code>3440</code> in the code and that the loop is around
<code>163XX</code>, and also that at the beginning of the register
allocation, the shift by 3 is indeed outside of the loop as expected, so
coming back to the debug output, we first have:</p>
<pre class="console"><code>Removing 1 back-copies.
Removing 16328r|%3961:vreg_64 = COPY %890:vreg_64
  blit [3440r,3488B:0): [3440r;3488B)=0(%3961)(recalc)
  blit [16192B,38336B:0): [16192B;16312r)=0(%3961)(recalc) [16312r;16336r)=1(%3962)(recalc) [16336r;38336B)=0(%3961)(recalc)
  rewr %bb.6|   3440r:0|%3961:vreg_64 = V_LSHLREV_B64_e64 3, %3078:vreg_64, implicit $exec
  rewr %bb.90|  16320B:1|   undef %894.sub0:vreg_64, %3334:sreg_64_xexec = V_ADD_CO_U32_e64 %3326:sreg_32, %3962.sub0:vreg_64, 0, implicit $exec
  rewr %bb.90|  16336B:1|   %894.sub1:vreg_64, dead %3335:sreg_64_xexec = V_ADDC_U32_e64 %3340:vgpr_32, %3962.sub1:vreg_64, %3334:sreg_64_xexec, 0, implicit $exec
  rewr %bb.90|  16312B:0|   %3962:vreg_64 = COPY %3961:vreg_64</code></pre>
<p>Now this is in the middle of the register allocation modifications so
the code changed a little bit but looks sort of the same, it seems that
there’s now a copy inside of the loop of <code>%890</code> into
<code>%3961</code> and that this is trying to remove it. And we can see
the modified instructions in the <code>rewr</code> part:</p>
<pre class="console"><code>  rewr %bb.6|   3440r:0|%3961:vreg_64 = V_LSHLREV_B64_e64 3, %3078:vreg_64, implicit $exec
  rewr %bb.90|  16320B:1|   undef %894.sub0:vreg_64, %3334:sreg_64_xexec = V_ADD_CO_U32_e64 %3326:sreg_32, %3962.sub0:vreg_64, 0, implicit $exec
  rewr %bb.90|  16336B:1|   %894.sub1:vreg_64, dead %3335:sreg_64_xexec = V_ADDC_U32_e64 %3340:vgpr_32, %3962.sub1:vreg_64, %3334:sreg_64_xexec, 0, implicit $exec
  rewr %bb.90|  16312B:0|   %3962:vreg_64 = COPY %3961:vreg_64</code></pre>
<p>So at this point the addition instructions that used to take
<code>%890</code> take <code>%3962</code>, the shift is now writing to
<code>%3961</code> instead of <code>%890</code> and <code>%3961</code>
is copied into <code>%3962</code> before the additions.</p>
<p>And at this stage the shift is still outside of the loop which seems
fine, so we can move on to the next part of the output, and namely the
inline spilling part:</p>
<pre class="console"><code>Inline spilling VReg_64:%3961 [3440r,3488B:0)[16192B,38336B:0) 0@3440r  L000000000000000C [3440r,3488B:1)[16192B,38336B:1) 0@x 1@3440r  L0000000000000003 [3440r,3488B:1)    [16192B,38336B:1) 0@x 1@3440r  weight:3.681593e-04
From original %890
|   remat:  16308r| %3963:vreg_64 = V_LSHLREV_B64_e64 3, %3078:vreg_64, implicit $exec
|           16312e| %3962:vreg_64 = COPY killed %3963:vreg_64</code></pre>
<p>This is important because this is the first time we see the shift by
3 instruction moved into the loop, as you can see in <code>16308</code>
instead of <code>3440</code>.</p>
<p>And you can then see the compiler delete the original shift
instruction:</p>
<pre class="console"><code>All defs dead: dead %3961:vreg_64 = V_LSHLREV_B64_e64 3, %3078:vreg_64, implicit $exec
Remat created 1 dead defs.
Deleting dead def 3440r|dead %3961:vreg_64 = V_LSHLREV_B64_e64 3, %3078:vreg_64, implicit $exec</code></pre>
<p>And then restart the register allocation for it since the instruction
was moved:</p>
<pre class="console"><code>unassigning %3078 from $vgpr8_vgpr9: VGPR8_LO16 VGPR8_HI16 VGPR9_LO16 VGPR9_HI16
Enqueuing %3078
Shrink: %3078 [2224r,2240r:0)[2240r,3488B:1)[16192B,38336B:1) 0@2224r 1@2240r  L0000000000000003 [2224r,3440r:0) 0@2224r  L000000000000000C [2240r,3488B:0)[16192B,38336B    :0) 0@2240r  weight:1.520717e-01</code></pre>
<p>Now in practice it took a bit more debugging but here we can start to
see where the problem is coming from on the last line:</p>
<pre class="console"><code>%3078 [2224r,2240r:0)[2240r,3488B:1)[16192B,38336B:1) 0@2224r 1@2240r  L0000000000000003 [2224r,3440r:0) 0@2224r  L000000000000000C [2240r,3488B:0)[16192B,38336B:0) 0@2240r</code></pre>
<p>What this represents is the live ranges for the virtual register
<code>%3078</code>, which means the parts of the code where the register
is considered “alive”, so essentially all the code between the
instruction that defines the register and its last use, but let’s break
it down a bit further:</p>
<pre class="console"><code>[2224r,2240r:0)[2240r,3488B:1)[16192B,38336B:1) 0@2224r 1@2240r</code></pre>
<p>This first part tracks the liveness of the full register, these live
intervals contain two “values” (and/or definitions),
<code>0@2224r</code> and <code>1@2240r</code>, indeed if we look at the
full Machine IR:</p>
<pre class="console"><code>2224B|    undef %3078.sub0:vreg_64 = V_LSHRREV_B32_e32 5, %19:vgpr_32, implicit $exec
2240B|    %3078.sub1:vreg_64 = V_MOV_B32_e32 0, implicit $exec</code></pre>
<p>This defines the two sub-registers of <code>%3078</code>. And so what
the rest of the notation shows us is that <code>%3078</code> is alive
between <code>2224</code> and <code>2240</code> for value
<code>0</code>: <code>[2224r,2240r:0)</code>, then is alive between
<code>2240</code> to <code>3488</code> for value <code>1</code>:
<code>[2240r,3488B:1)</code>, and then between <code>16192</code> to
<code>38336</code> for value <code>1</code>:
<code>[16192B,38336B:1)</code>.</p>
<p>Now as you can probably tell this notation of the live range seems a
little strange because it is for the full register, but here the values
<code>0</code> and <code>1</code> are only defining parts of the
register, and so we need to look at the rest of the representation of
the live range which shows us information about the sub-registers:</p>
<pre class="console"><code>L0000000000000003 [2224r,3440r:0) 0@2224r
L000000000000000C [2240r,3488B:0)[16192B,38336B:0) 0@2240r</code></pre>
<p>The notation here is similar to the notation above, with the initial
value being a mask representing a sub-register, in binary
<code>0x3</code> is <code>0011</code> and <code>0xC</code> is
<code>1100</code>. And so looking at these two lines you can see that
the first, <code>0x3</code> represents <code>%3078.sub0</code> and
<code>0xC</code> represents <code>%3078.sub1</code>.</p>
<p>And so now we know that <code>%3078.sub0</code> is defined at
<code>2224</code> and is alive between <code>2224</code> and
<code>3440</code>, which means it’s alive until the shift by 3 but not
further. However <code>%3078.sub1</code> is defined at <code>2240</code>
and is alive between <code>2240</code> and <code>3488</code> which means
it’s alive past the shift, but not only that, it is also alive between
<code>16192</code> and <code>38336</code>, this second interval is
important because it covers the loop with our problematic load.</p>
<p>Now that we understand the live intervals of <code>%3078</code> the
problem becomes fairly obvious when looking back at the inline
spilling:</p>
<pre class="console"><code>Inline spilling VReg_64:%3961 [3440r,3488B:0)[16192B,38336B:0) 0@3440r  L000000000000000C [3440r,3488B:1)[16192B,38336B:1) 0@x 1@3440r  L0000000000000003 [3440r,3488B:1)    [16192B,38336B:1) 0@x 1@3440r  weight:3.681593e-04
From original %890
|   remat:  16308r| %3963:vreg_64 = V_LSHLREV_B64_e64 3, %3078:vreg_64, implicit $exec
|           16312e| %3962:vreg_64 = COPY killed %3963:vreg_64</code></pre>
<p>This code moved the shift by 3 inside the loop, but at
<code>16308</code> where we know that <code>%3078.sub0</code> is not
alive, and this is the virtual register that ultimately gets assigned to
<code>v8</code>. And so it makes sense that <code>v8</code> was being
re-used, because as far as the compiler is aware it is not supposed to
be used at that point.</p>
<p>Thus we’re almost done, we know that the instruction is being
incorrectly moved into the loop, we just need to find how this error
manifests in the code and how to fix it. To do that we can simply search
for the printed keywords such as <code>remat:</code> or
<code>Inline spilling</code> and then follow the code from there. It
took a little more time until reaching the following code in
<code>LiveRangeEdit::allUsesAvailableAt</code>:</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Check that subrange is live at UseIdx.</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>MO<span class="op">.</span>getSubReg<span class="op">())</span> <span class="op">{</span></span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> TargetRegisterInfo <span class="op">*</span>TRI <span class="op">=</span> MRI<span class="op">.</span>getTargetRegisterInfo<span class="op">();</span></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>  LaneBitmask LM <span class="op">=</span> TRI<span class="op">-&gt;</span>getSubRegIndexLaneMask<span class="op">(</span>MO<span class="op">.</span>getSubReg<span class="op">());</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span>LiveInterval<span class="op">::</span>SubRange <span class="op">&amp;</span>SR <span class="op">:</span> li<span class="op">.</span>subranges<span class="op">())</span> <span class="op">{</span></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">((</span>SR<span class="op">.</span>LaneMask <span class="op">&amp;</span> LM<span class="op">).</span>none<span class="op">())</span></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>      <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>SR<span class="op">.</span>liveAt<span class="op">(</span>UseIdx<span class="op">))</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>      <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb57-10"><a href="#cb57-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-11"><a href="#cb57-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Early exit if all used lanes are checked. No need to continue.</span></span>
<span id="cb57-12"><a href="#cb57-12" aria-hidden="true" tabindex="-1"></a>    LM <span class="op">&amp;=</span> <span class="op">~</span>SR<span class="op">.</span>LaneMask<span class="op">;</span></span>
<span id="cb57-13"><a href="#cb57-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>LM<span class="op">.</span>none<span class="op">())</span></span>
<span id="cb57-14"><a href="#cb57-14" aria-hidden="true" tabindex="-1"></a>      <span class="cf">break</span><span class="op">;</span></span>
<span id="cb57-15"><a href="#cb57-15" aria-hidden="true" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb57-16"><a href="#cb57-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The function this is in is trying to determine if all the uses of an
instructions are available at a given point, which is in turn used to
determine if it is valid to move the instruction there. And it is
checking for sub-register ranges, but only if the operand of the
instruction is using a sub-register. This is not the case for us, our
shift instruction uses the full register, but one of the sub-register is
not alive at the destination, and so this code ends up not checking our
instruction for sub-ranges and incorrectly moves the shift into the
loop.</p>
<p>The fix is then fairly simple, we just need to always check the
sub-ranges when they’re available, and so tweaking the code above as
follows resolved the issue:</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Check that subrange is live at UseIdx.</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>li<span class="op">.</span>hasSubRanges<span class="op">())</span> <span class="op">{</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>  <span class="at">const</span> TargetRegisterInfo <span class="op">*</span>TRI <span class="op">=</span> MRI<span class="op">.</span>getTargetRegisterInfo<span class="op">();</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">unsigned</span> SubReg <span class="op">=</span> MO<span class="op">.</span>getSubReg<span class="op">();</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>  LaneBitmask LM <span class="op">=</span> SubReg <span class="op">?</span> TRI<span class="op">-&gt;</span>getSubRegIndexLaneMask<span class="op">(</span>SubReg<span class="op">)</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>                          <span class="op">:</span> MRI<span class="op">.</span>getMaxLaneMaskForVReg<span class="op">(</span>MO<span class="op">.</span>getReg<span class="op">());</span></span></code></pre></div>
<p>With this patch instead of checking the sub-ranges only if the
instruction is using a sub-register, it checks them if they exist, and
if the instruction is using the full register, it uses a mask containing
both sub-registers to check them both.</p>
<p>And so, the inline spilling fails to move the shift instruction in
the loop:</p>
<pre class="console"><code>Inline spilling VReg_64:%3961 [3440r,3488B:0)[16192B,38336B:0) 0@3440r  L000000000000000C [3440r,3488B:1)[16192B,38336B:1) 0@x 1@3440r  L0000000000000003 [3440r,3488B:1)    [16192B,38336B:1) 0@x 1@3440r  weight:3.681593e-04
From original %890
|   cannot remat for 16312e|%3962:vreg_64 = COPY %3961:vreg_64</code></pre>
<p>And since it can’t “inline” the spill it simply resorts to a normal
spill:</p>
<pre class="console"><code>Merged spilled regs: SS#2 [3440r,3488B:0)[16192B,38336B:0) 0@x  weight:0.000000e+00
spillAroundUses %3961
|   rewrite: 3440r| %3963:vreg_64 = V_LSHLREV_B64_e64 3, %3078:vreg_64, implicit $exec

|   spill:   3448r| SI_SPILL_V64_SAVE killed %3963:vreg_64, %stack.2, $sgpr32, 0, implicit $exec :: (store (s64) into %stack.2, align 4, addrspace 5)
Checking redundant spills for 0@16312r in %3962 [16312r,16336r:0) 0@16312r  L000000000000000C [16312r,16336r:0) 0@16312r  L0000000000000003 [16312r,16320r:0) 0@16312r  w    eight:5.705815e-02
Merged to stack int: SS#2 [3440r,3488B:0)[16192B,38336B:0) 0@x  weight:0.000000e+00
|   folded:   16312r|   %3962:vreg_64 = SI_SPILL_V64_RESTORE %stack.2, $sgpr32, 0, implicit $exec :: (load (s64) from %stack.2, align 4, addrspace 5)</code></pre>
<p>And the code generated this way is now correct meaning that the
GROMACS test now passes on <code>gfx906</code>.</p>
<h2 id="conclusion"><a href="#conclusion">Conclusion</a></h2>
<p>Finding the root cause of this issue was an interesting journey that
took us from a molecular dynamics kernel all the way down to the AMD GPU
ISAs.</p>
<p>Through describing this journey, this blog post provides some insight
on a number of techniques that can be used either when debugging issues
in the LLVM project, in DPC++ , or when working in an environment with
limited debugging capabilities. And it also shows a glimpse into the
DPC++ and LLVM components used during the compilation of GPU kernels.
Which may hopefully be helpful to anyone wanting to learn more about
these technologies.</p>
<p>And in closing, the full patch fixing this specific issue was
submitted to upstream LLVM and promptly merged:</p>
<ul>
<li><a href="https://reviews.llvm.org/D131884"
class="uri">https://reviews.llvm.org/D131884</a></li>
</ul>
</div>

<footer>
  <div class="mid">Nicolas Miller</div>
  <div class="bot">August 2025</div>
</footer>
</body>
</html>
